{"meta":{"title":"MinQo的blog","subtitle":"","description":"","author":"MinQo","url":"http://MinQo.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-01-21T07:41:54.000Z","updated":"2022-01-21T07:44:29.871Z","comments":true,"path":"tags/index.html","permalink":"http://minqo.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-21T07:43:33.000Z","updated":"2022-01-21T07:44:13.802Z","comments":true,"path":"categories/index.html","permalink":"http://minqo.github.io/categories/index.html","excerpt":"","text":""},{"title":"四大皆空","date":"2022-01-21T07:47:16.467Z","updated":"2022-01-21T07:47:16.455Z","comments":true,"path":"/404.html","permalink":"http://minqo.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2022-01-21T07:45:21.000Z","updated":"2022-04-28T00:54:00.805Z","comments":true,"path":"about/index.html","permalink":"http://minqo.github.io/about/index.html","excerpt":"","text":"北京信息科技大学:MinQo联系方式：qq:2537876428wechat:iMinQo"},{"title":"links","date":"2022-01-21T07:47:38.000Z","updated":"2022-01-21T07:47:38.819Z","comments":true,"path":"links/index.html","permalink":"http://minqo.github.io/links/index.html","excerpt":"","text":""},{"title":"如何用c语言做一个简易推箱子游戏","date":"2021-11-24T12:23:07.000Z","updated":"2021-11-25T06:57:20.489Z","comments":true,"path":"categories/游戏/如何用c语言做一个简易推箱子游戏.html","permalink":"http://minqo.github.io/categories/%E6%B8%B8%E6%88%8F/%E5%A6%82%E4%BD%95%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F.html","excerpt":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。","text":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。 二.角色的移动在打印地图中，我们确定了角色的位置。所以要想让角色移动，得要让角色的坐标随输入的移动位置而相应的改变，然后再重新打印地图。(细节:定义新行、列的指针指向初始位置的地址，移动后新坐标的值改变–将初始坐标保存) 三.移动过程中的各种情况1.移动方向为墙或者目标点输出禁止前行/坐标不改变2.移动的目标点是空白角色对应的值赋值给新坐标，空白的值赋给人的原坐标，再把新坐标赋值给原坐标(新一轮的坐标替换)3.移动的目标点是箱子将新坐标的值赋值给下一个坐标，移动角色，下一个坐标(箱子的坐标)对应改变①.改变的位置是墙或箱子输出移动不了②.改变的位置是空白箱子的值赋给改变后的坐标，角色的值赋给箱子的坐标，空白的值赋给原坐标的指针，再原坐标指针指向角色的位置坐标(保证指针一直指向角色位置的坐标)③.改变的位置是目标点在②中，目标点坐标对应的值将被箱子的值覆盖，不需设置额外变量计算目标点个数(在重新打印地图中计算目标点的值的个数) 四.判断先对地图做一次循环，确定目标点的个数，并赋值给一个变量，当这个这个变量为0时，游戏胜利。(在移动中可设置一个输入值为认输) 五.优化1.设置一个菜单，让玩家进行选择 2.设置多关卡 3.利用函数，结构清晰 六.问题1.地图需要自己排版2.关卡需要自己设计，每次加一个关卡都要重写一个函数3.游戏单调，无音效，图片特效。七.所学1.学习了大程序的函数结构布局，让代码清晰2.学习了_getch()、exit(0)、system(“cls”)、等新知识3.c语言代码的新用法八.游戏实况"}],"posts":[{"title":"JavaLearnNote","slug":"JavaLearnNote","date":"2022-05-19T01:01:14.000Z","updated":"2022-05-27T13:04:04.405Z","comments":true,"path":"2022/05/19/JavaLearnNote/","link":"","permalink":"http://minqo.github.io/2022/05/19/JavaLearnNote/","excerpt":"","text":"序之前一直在看黑马程序员的Java教程，平时记录也就是把视频中的ppt截图存放。但是时间久了发现之前很多内容都没有记牢，熟用。现在改用文字记录总结平时学习到的内容，同时学会熟练使用MarkDown写法。Java官方API文档。 JavaSe 零散点 Java文件的名称和Public修饰的类名相同，类中包含一个或多个方法，从main方法开始执行 final修饰的变量不可重新赋值改变，final声明的类为最终类，不能被继承 只有当被除数是负数时余数才是负数 强制类型转换–&gt;(类型)变量 sc.next()读取以空格为结束的字符串，sc.nextLine()读取以回车会结束的字符串 数值型字符串转换为整数–&gt;int 变量名 = Interger.parseInt(字符串) 数组间用=表示新数组指向原数组 重载方法-&gt;同名不同参 不可变集合List.of(“”,””)返回一个集合 finally之前的try中如果有return语句，会先执行finally语句再执行return语句 static{}可用于初始化，main方法之前执行 打印一个对象，会默认调用toString方法，如果没重写toString方法，就返回对象地址 接口中的方法默认由public abstract修饰，常量默认由public static final修饰 接口中被default修饰的方法可以直接补全方法的代码，接口被实现后可直接使用该方法 字符串 toCharArray()-&gt;将字符串拆分返回一个字符数组 substring(start,end)-&gt;从start开始到end截取字符串返回一个新字符串 replace(“a”,”b”)-&gt;将字符串中的a全部替换成b split(“,”)-&gt;将字符串以”,”分隔，返回一个字符串数组 多态格式: 父类 实例对象名称 = new 子类构造器 父类转子类(instanceof判断) -&gt; 子类 名称 = (子类)实例对象名称 方法调用: 编译看左边，运行看右边 变量调用: 编译，运行都看左边 时间类+格式化时间Date类Date类位于util包内，用于操作时间。格式: Date nowTime = new Date(ms);当ms存在时，将该毫秒值转换为日期对象 方法: getTime()获取毫秒值(距1970年01月01日 00时00分00秒)、System类中的currentTimeMillis()也可以获取毫秒值 SimpleDateFormat类格式: SimpleDateFormat 对象名称 = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss EEE a”); 调用对象的format(Date类)方法返回一个格式化后的字符串 调用对象的parse(格式化字符串)返回一个的Date类 实例: 123456789101112// 格式化时间SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss Ea&quot;);//获取当前时间String nowTime = &quot;2022年05月19日 21:10:53 星期六 上午&quot;;//将格式化后的时间转换为日期对象Date d = sdf.parse(nowTime);//获得日期对象的毫秒数Long time = d.getTime();//经过1天2小时2分钟2秒Long time2 = time + (24*3600+2*3600+2*60+2)*1000;//将时间格式化System.out.println(sdf.format(time2)); Calendar类Calendar是一个抽象类，不能直接创建对象。 方法: get(int field)返回日期某个字段信息(Year、Month、Day) set(int field,int value)修改日历的某个字段信息 add(int field,int amount)为某个字段增/减指定的值 getTime()拿到此刻日期对象，返回一个Date对象 getTimeInMillis()拿到此刻时间毫秒值 正则表达式方法: matches(),判断是否匹配正则表达式，返回Boolean类型 字符类 [abc]指定字符 [^abc]除了指定字符外的字符 [a-zA-Z]从a(A)到z(Z)包括 [a-d[m-p]]从a到d或从m到p [a-z&amp;&amp;[^def]]从a到z除去指定字符 [a-z&amp;&amp;[^m-p]]从a到z除去指定范围字符 预定义字符 .任何字符 \\d一个数字[0-9] \\D非数字[^0-9] \\s一个空白字符[\\t\\n\\x0B\\f\\r] \\S非空白字符[^\\s] \\w英文、数字、下划线[a-zA-Z_0-9] \\W一个非单词字符[^\\w] 贪婪量词 X? x,一次或无 x* x,0次或多次 x+ x,一次或多次 x[n] x,n次 x[n,] x,至少n次 x[n,m] x,至少n不超过m Lambda表达式简化函数式接口(接口中有且仅有一个抽象方法,通常加@FunctionalInterface注解)匿名内部类的代码写法 格式: (匿名内部类被重写方法的形参列表)-&gt;{被重写方法的代码} 实例: 12345678910111213141516public class LambdaDemo1 &#123; public static void main(String[] args) &#123; run( () -&gt;&#123; System.out.println(&quot;放飞&quot;); &#125;); &#125; public static void run(Play p)&#123; p.fly(); &#125;&#125;@FunctionalInterfaceinterface Play&#123; void fly();&#125; 泛型格式: 修饰符 class 类名&lt;泛型变量&gt;{} 泛型方法 修饰符 &lt;泛型变量&gt; 返回类型 名称(){} 泛型类 修饰符 interface 接口名称&lt;泛型变量&gt;{} 泛型接口 作用: 编译阶段指定数据类型 泛型接口可以让实现类选择当前功能需要操作的数据类型 拓展: 其中?作为通配符, 表示?必须是car或其子类(或其父类) Collection集合List系列集合元素有序、可重复、有索引 ArrayList有序、可重复、有索引 LinkedList有序、可重复、有索引Set系列集合 元素无序、不重复、无索引 HashSet无序、不重复、无索引 LinkedHashSet有序、不重复、无索引 TreeSet按大小默认升序、不重复、无索引","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"http://minqo.github.io/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://minqo.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"如何用py做一个exe应用程序","slug":"如何做一个exe应用程序","date":"2022-02-05T11:51:54.000Z","updated":"2022-04-28T00:56:45.688Z","comments":true,"path":"2022/02/05/如何做一个exe应用程序/","link":"","permalink":"http://minqo.github.io/2022/02/05/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AAexe%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","excerpt":"工具 pycharm pip(Python包管理工具) pyinstaller库 操作安装pip先在pip官网下载pip压缩包并压缩,然后在命令行进入到压缩完后的文件夹目录并输入python setup.py install,安装完成后输入cd..(退出文件夹),输入命令pip –version可以看到版本则安装成功。最后将python目录中的script填入环境变量 安装pyinstaller库在命令行输入pip install pyinstall -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com 这里将pip源换成清华源、阿里源等都适用。","text":"工具 pycharm pip(Python包管理工具) pyinstaller库 操作安装pip先在pip官网下载pip压缩包并压缩,然后在命令行进入到压缩完后的文件夹目录并输入python setup.py install,安装完成后输入cd..(退出文件夹),输入命令pip –version可以看到版本则安装成功。最后将python目录中的script填入环境变量 安装pyinstaller库在命令行输入pip install pyinstall -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com 这里将pip源换成清华源、阿里源等都适用。 代码这里写的是一个查询文件夹内代码行数的程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import easygui as gimport osdef show(start_dir): lines = 0 total = 0 text = &#x27;&#x27; for i in source_list: lines = source_list[i] total += lines text += (&#x27;【%s】文件共有%d个，代码量共%d行\\n&#x27; % (i,file_list[i],lines)) if total &lt; 10000: msg = &#x27;您目前共累积编写了%d行代码，完成进度:%.2f %% \\n离10万行代码还差%d行，请继续努力！&#x27; % (total,total/1000,100000-total) title = &#x27;结果&#x27; g.textbox(msg,title,text) elif total &gt; 10000: msg = &#x27;您目前共累积编写了%d行代码，完成进度:%.2f %% \\n超过10万行代码%d行，请继续努力！&#x27; % (total, total / 1000, total - 100000) title = &#x27;结果&#x27; g.textbox(msg, title, text) else : msg =&#x27;完成进度:%.2f %% \\n刚好写了10万行代码，请继续努力！&#x27; % (total / 1000) title = &#x27;结果&#x27; g.textbox(msg,title,text)def num_file(file_name): lines = 0 with open(file_name) as f: print(&#x27;正在分析【%s】文件&#x27; % file_name) try: for each_line in f: lines += 1 except UnicodeDecodeError : pass #不计因编码产生的差错 return linesdef search_file(start_dir): os.chdir(start_dir) for each_file in os.listdir(os.curdir) : ext = os.path.splitext(each_file)[1] if ext in target: # 查询代码量 num = num_file(each_file) try : file_list[ext] += 1 except KeyError: file_list[ext] = 1 try : source_list[ext] += num except KeyError: source_list[ext] = num if os.path.isdir(each_file): search_file(each_file) os.chdir(os.pardir)target = [&#x27;.c&#x27;,&#x27;.css&#x27;,&#x27;.py&#x27;,&#x27;.java&#x27;,&#x27;.cpp&#x27;,&#x27;.html&#x27;,&#x27;.js&#x27;]file_list = &#123;&#125;source_list = &#123;&#125;g.msgbox(&#x27;请打开你需要查询代码量的文件夹&#x27;,&#x27;代码量查询&#x27;)path = g.diropenbox(&#x27;请选择代码库&#x27;)search_file(path)show(path) exe文件打包将写完的.py文件放在文件夹中,在命令行cd进入py文件所在目录，输入pyinstaller -F -w 名.py(-w是消除exe文件控制框)等待完成后就会生成exe程序文件 快捷式在桌面新建快捷式，选择到所完成的exe文件，之后就可以更改名称及图标了","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"python","slug":"python","permalink":"http://minqo.github.io/tags/python/"}]},{"title":"如何用c语言做一个简易推箱子游戏","slug":"如何用c语言做一个简易推箱子游戏","date":"2021-11-24T12:23:07.000Z","updated":"2021-11-25T06:57:20.489Z","comments":true,"path":"2021/11/24/如何用c语言做一个简易推箱子游戏/","link":"","permalink":"http://minqo.github.io/2021/11/24/%E5%A6%82%E4%BD%95%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。","text":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。 二.角色的移动在打印地图中，我们确定了角色的位置。所以要想让角色移动，得要让角色的坐标随输入的移动位置而相应的改变，然后再重新打印地图。(细节:定义新行、列的指针指向初始位置的地址，移动后新坐标的值改变–将初始坐标保存) 三.移动过程中的各种情况1.移动方向为墙或者目标点输出禁止前行/坐标不改变2.移动的目标点是空白角色对应的值赋值给新坐标，空白的值赋给人的原坐标，再把新坐标赋值给原坐标(新一轮的坐标替换)3.移动的目标点是箱子将新坐标的值赋值给下一个坐标，移动角色，下一个坐标(箱子的坐标)对应改变①.改变的位置是墙或箱子输出移动不了②.改变的位置是空白箱子的值赋给改变后的坐标，角色的值赋给箱子的坐标，空白的值赋给原坐标的指针，再原坐标指针指向角色的位置坐标(保证指针一直指向角色位置的坐标)③.改变的位置是目标点在②中，目标点坐标对应的值将被箱子的值覆盖，不需设置额外变量计算目标点个数(在重新打印地图中计算目标点的值的个数) 四.判断先对地图做一次循环，确定目标点的个数，并赋值给一个变量，当这个这个变量为0时，游戏胜利。(在移动中可设置一个输入值为认输) 五.优化1.设置一个菜单，让玩家进行选择 2.设置多关卡 3.利用函数，结构清晰 六.问题1.地图需要自己排版2.关卡需要自己设计，每次加一个关卡都要重写一个函数3.游戏单调，无音效，图片特效。七.所学1.学习了大程序的函数结构布局，让代码清晰2.学习了_getch()、exit(0)、system(“cls”)、等新知识3.c语言代码的新用法八.游戏实况","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"游戏","slug":"游戏","permalink":"http://minqo.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"第一篇的感悟","slug":"第一篇的感悟","date":"2021-11-24T10:58:53.000Z","updated":"2021-11-25T06:57:17.302Z","comments":true,"path":"2021/11/24/第一篇的感悟/","link":"","permalink":"http://minqo.github.io/2021/11/24/%E7%AC%AC%E4%B8%80%E7%AF%87%E7%9A%84%E6%84%9F%E6%82%9F/","excerpt":"","text":"待会再感悟","categories":[],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://minqo.github.io/tags/%E6%84%9F%E6%82%9F/"}]}],"categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"http://minqo.github.io/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://minqo.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"python","slug":"python","permalink":"http://minqo.github.io/tags/python/"},{"name":"游戏","slug":"游戏","permalink":"http://minqo.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"感悟","slug":"感悟","permalink":"http://minqo.github.io/tags/%E6%84%9F%E6%82%9F/"}]}