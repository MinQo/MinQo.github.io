{"meta":{"title":"MinQo的blog","subtitle":"","description":"","author":"MinQo","url":"http://MinQo.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-01-21T07:41:54.000Z","updated":"2022-01-21T07:44:29.871Z","comments":true,"path":"tags/index.html","permalink":"http://minqo.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-21T07:43:33.000Z","updated":"2022-01-21T07:44:13.802Z","comments":true,"path":"categories/index.html","permalink":"http://minqo.github.io/categories/index.html","excerpt":"","text":""},{"title":"四大皆空","date":"2022-01-21T07:47:16.467Z","updated":"2022-01-21T07:47:16.455Z","comments":true,"path":"/404.html","permalink":"http://minqo.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2022-01-21T07:45:21.000Z","updated":"2022-04-28T00:54:00.805Z","comments":true,"path":"about/index.html","permalink":"http://minqo.github.io/about/index.html","excerpt":"","text":"北京信息科技大学:MinQo联系方式：qq:2537876428wechat:iMinQo"},{"title":"links","date":"2022-01-21T07:47:38.000Z","updated":"2022-01-21T07:47:38.819Z","comments":true,"path":"links/index.html","permalink":"http://minqo.github.io/links/index.html","excerpt":"","text":""},{"title":"如何用c语言做一个简易推箱子游戏","date":"2021-11-24T12:23:07.000Z","updated":"2021-11-25T06:57:20.489Z","comments":true,"path":"categories/游戏/如何用c语言做一个简易推箱子游戏.html","permalink":"http://minqo.github.io/categories/%E6%B8%B8%E6%88%8F/%E5%A6%82%E4%BD%95%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F.html","excerpt":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。","text":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。 二.角色的移动在打印地图中，我们确定了角色的位置。所以要想让角色移动，得要让角色的坐标随输入的移动位置而相应的改变，然后再重新打印地图。(细节:定义新行、列的指针指向初始位置的地址，移动后新坐标的值改变–将初始坐标保存) 三.移动过程中的各种情况1.移动方向为墙或者目标点输出禁止前行/坐标不改变2.移动的目标点是空白角色对应的值赋值给新坐标，空白的值赋给人的原坐标，再把新坐标赋值给原坐标(新一轮的坐标替换)3.移动的目标点是箱子将新坐标的值赋值给下一个坐标，移动角色，下一个坐标(箱子的坐标)对应改变①.改变的位置是墙或箱子输出移动不了②.改变的位置是空白箱子的值赋给改变后的坐标，角色的值赋给箱子的坐标，空白的值赋给原坐标的指针，再原坐标指针指向角色的位置坐标(保证指针一直指向角色位置的坐标)③.改变的位置是目标点在②中，目标点坐标对应的值将被箱子的值覆盖，不需设置额外变量计算目标点个数(在重新打印地图中计算目标点的值的个数) 四.判断先对地图做一次循环，确定目标点的个数，并赋值给一个变量，当这个这个变量为0时，游戏胜利。(在移动中可设置一个输入值为认输) 五.优化1.设置一个菜单，让玩家进行选择 2.设置多关卡 3.利用函数，结构清晰 六.问题1.地图需要自己排版2.关卡需要自己设计，每次加一个关卡都要重写一个函数3.游戏单调，无音效，图片特效。七.所学1.学习了大程序的函数结构布局，让代码清晰2.学习了_getch()、exit(0)、system(“cls”)、等新知识3.c语言代码的新用法八.游戏实况"}],"posts":[{"title":"MysqlLearnNote","slug":"MysqlLearnNote","date":"2022-06-19T01:01:01.000Z","updated":"2022-07-22T06:44:09.829Z","comments":true,"path":"2022/06/19/MysqlLearnNote/","link":"","permalink":"http://minqo.github.io/2022/06/19/MysqlLearnNote/","excerpt":"","text":"概述数据库：DataBase(DB)存储数据的仓库，实际就是一些文件，文件中存储了特定格式的数据。数据库管理系统：DataBaseManagementSystem(DBMS)专门用来管理数据库。 常见数据库管理系统： Mysql、Oracle等SQL：格式化查询语言，通过编写SQL语句，然后DBMS执行SQL语句来进行数据库管理(通用标准语言)关系：DBMS–执行–&gt;SQL –&gt;操作–&gt;DB SQL语句分类 DQL：数据查询语言(带有select关键字) DML：数据库操作语言(对表中数据进行增删改) insert/delete/update DDL：数据定义语言(主要操作表的结构)create/drop/alter TCL：事务控制语言(事务提交:commit; // 事务回滚:rollback;….) DCL：数据控制语言(授权grant // 撤销权限revoke….) 数据类型 int//integer大整数值(4bytes) float单精度浮点数值(4bytes) double双精度浮点数值(8bytes) date日期值(now()获取当前日期) time时间值或持续时间 year年份值 char定长字符串(0-255bytes) name char(10)–10个字符空间(固定) 存储性能高浪费空间 varchar变长字符串(0-65535bytes) name varchar(10)–最高10个字符空间(看实际) 处理函数 lower(列名)转换小写 upper()大写 substr(字符串，启示下标(从1开始)，截取长度) length()取长度 trim()去空格 str_to_date(‘字符串日期’,’日期格式(%Y-%m-%d %h:%i:%s)’) 字符串转日期 date_format(日期类型数据,’日期格式’) data类型转换成格式化的varchar字符串 format(数字.’格式’)数字格式化 round(数，保留小数个数)四舍五入 rand()生成随机数 ifnull(数据，被当做哪个值)数据为null时会改成其他值 Mysql mysql数据库启动时，服务占有默认端口号为3306 计算机-&gt;管理-&gt;服务可以选择Mysql启动关闭 // 在命令行中net start/stop 服务名称 mysql本地登录: mysql -uroot -p密码 // 退出: exit 导入数据source 路径(.sql文件) 字符串用单引号,虽然在mysql可以用双引号,但在oracle中不行 常用命令 退出mysql：exit 查看mysql中的数据库：show databases; 使用某个数据库：use 数据库名称; 查看当前使用的数据库：select database(); 创建数据库：create database 数据库名称; 删除数据库：drop database 数据库名称; 快速复制表：create table mytable as select * from yourtable; 表Tables–数据库中的最基本单元,有行(数据/记录)与列(字段)显示直观 聚合函数概念：将一列数据作为一个整体,进行纵向计算语法：select 聚合函数名(列名) from 表;(null值不参与所有聚合函数运算) count()统计数量(一般选不为null的列) max()最大值 min()最小值 sum()求和 avg()平均值 DDLDDL操作数据库 查询–show databases; 创建–create database 数据库名称; 创建(条件)–create database if not exists 数据库名称; 删除–drop database if exists 数据库名称; 查看当前使用数据库–select database(); 使用数据库–use 数据库名称; DDL操作表 查询–show tables; 查询表结构–desc 表名称; 创建–create table 表名( 字段名1 数据类型1, 字段名2 数据类型2,); 删除表–drop table if exists 表名; 修改表名–alter table 表名 rename to 新表名; 添加一列–alter table 表名 add 列名 数据类型; 修改数据类型–alter table 表名 modify 列名 新数据类型; 修改列名及数据类型–alter table 表名 change 列名 新列名 新数据类型; 删除列–alter table 表名 drop 列名; DML添加数据 指定列添加–insert into 表名(列名1,列名2,…) values(值1,值2,…); 全部列添加–insert into 表名 values(值1,值2,…); 批量添加–insert into 表名(列1,列2,…) values(值1,值2,…),(值1,值2,…); 修改数据 update 表名 set 列名1=值1,列名2=值2,…[where 条件];(不加条件则所有数据都改)删除数据 delete from 表名 [where 条件]; DQL查询语法123456789101112131415//顺序不可改变select 字段列表from 表名列表where 条件列表group by 分组字段having 分组后条件order by 排序字段limit 分页限定 基础查询 查询多个字段–select 字段列表 from 表名; 查询所有数据–select * from 表名; 去除重复记录–select distinct 字段列表 from 表名;（distinct放在所有字段最前面，字段联合再去除） 起别名–as(可省略); 条件查询 语法–select 字段列表 from 表名 where 条件列表; 大于&gt; // 小于&lt; // 大于等于&gt;= // 不等于&lt;&gt;或!= 在某个范围(包含)between…and… // 在其中in(…) 占位符(_单个任意字符 // %多个任意字符) 是null(is null) // 不是null(is not null) 并且(and或&amp;&amp;) // 或者(or或||) //非(not或！) 模糊查询 like ‘占位符’ 排序查询 语法–select 字段列表 from 表名 order by 排序字段名1 [排序方式1],排序字段名2 [排序方式2]…; asc升序排列(默认) // desc降序排列 select * from stu order by math desc,english asc; //数学一样时再按英语升序排列 分组查询分组后，查询的字段为聚合函数和分组字段，查询其他字段无意义 语法–select 字段列表 from 表名 [where 分组前条件限定] group by 分组字段名 [having 分组后条件过滤];where与having区别 where在分组前限定，不满足where条件不参与分组，having在分组后进行过滤 where不能对聚合函数进行判断，having可以 执行顺序：where&gt;聚合函数&gt;having(优先选择where)实例：1select sex,avg(math),count(*) from stu where math&gt;70 group by sex having count(*)&gt;2;//查询男女同学各自数学平均分及人数，其中分数低于70不参与分组，分组后人数大于2 分页查询 语法–select 字段列表 from 表名 limit 起始索引(从0开始),查询条目数; 计算公式：起始索引 = (当前页码-1)*每页显示的条数 select * from stu limit 6,3; //每页显示3条数据，查询第三页数据 连接查询跳转到 连接 子查询select语句中嵌套select语句，被嵌套的select语句被称为子查询(当做新表) 语法 单行单列–select 字段列表 from 表 where 字段名 = (子查询); 多行单列–select 字段列表 from 表 where 字段名 in (字符串); 多行多列–select 字段列表 from (子查询) where 条件; 实例：12345678select t.*,s.gradefrom select (job,**avg(sal) as avgsal** from emp group by job) tjoin salgrade son t.avgsal between s.losal and s.hisal; 约束概念：作用于列上的规则，用于限制加入表的数据分类： 非空约束：列中所有数据不能有null值 唯一约束：列中数据各不相同 主键约束：主键是一行数据的唯一标识，要求非空且唯一 检查约束：列中的值满足某一条件 默认约束：未指定的值采用默认值 外键约束：外键用来让两个表的数据建立连接，保证数据的一致性和完整性 非空约束创建表时添加非空约束：create table 表名( 列名 数据类型 not null, …);建完表后添加非空约束：alter table 表名 modify 字段名 数据类型 not null;删除约束：alter table 表名 modify 字段名 数据类型; 唯一约束创建表时：create table 表名( 列名 数据类型 unique [auto_increment],//auto_increment：当不指定值时自动增长 ..);unique(列名1,列名2)表示列1与列2联合后唯一create table 表名( 列名 数据类型, … [constraint] [约束名称] unique(列名));建完表后：alter table 表名 modify 字段名 数据类型 unique; 主键约束创建表时：create table 表名( 列名 数据类型 primary key(主键字段), …); 主键字段的每个值叫做主键值 某字段被not null和unique同时约束时，改字段自动变成主键约束(oracle不同) primary key(列名1,列名2)表示列1与列2联合后唯一且不为空(复合主键,不建议使用,一张表只能一个主键)外键约束创建表时：create table 表名( 列名 数据类型, … [constraint] [外键名称] foreign key(外键列名) references 主表(主表列名));建完表后：alter table 表名 add constraint 外键名称 foreign key(外键字段名称) references 主表名称(主列表名称);删除约束：alter table 表名 drop foreign key 外键名称; 连接 连接内连接 单表内连接时将单表看做多张表隐式内连接：select 字段列表 from 表1，表2… where 条件;显示内连接：select 字段列表 from 表1 [inner] join 表2 on 连接条件 where 筛选条件;实例：1select e.name,d.dname from emp e join dept d on e.deptno = d.deptno; 外连接左外连接：select 字段列表 from 表1 left [outer] join 表2 on 条件;(1表所有数据及交集)右外连接：select 字段列表 from 表1 right [outer] join 表2 on 条件;(2表所有数据及交集)[outer]看着可读性强可省略 多表连接语法：select … from a join b on a/b连接条件 join c on a/c连接条件… 事物(重点) 一个事物是一个完整的业务逻辑(操作序列)，包含一组数据库操作命令，事物把所有命令作为整体，数据库命令同时成功/失败 只有DML语句和事物有关(insert delete update) 事物执行过程中，每一条DML操作都会记录到“事务性活动的日志文件”中 mysql默认情况下自动提交事务(每执行一条DML语句则提交一次)，start transaction关闭自动提交 select @@autocommit 查看事物的默认提交方式(set @@auutocommit = 0(手动提交)/1(自动)) select @@tx_isolation 查看隔离级别 set global transaction isolation level 隔离级别; //修改全局隔离级别 提交事物清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。提交事物标志着事物的结束。并且是一种全部成功的结束。 语句：commit 回滚事物将之前所有的DML操作全部撤销，并且清空事物性活动的日志文件。回滚事物标志着事物的结束。并且是一种全部失败的结束。 语句：rollback(回滚到上一次任务的提交点) 特性原子性 事物是最小的工作单元，不可再分。 一致性 在同一个事物中，所有操作必须同时成功或失败以保证数据的一致性 隔离性(操作同一张表) 两件事物之间有一定的隔离，隔离有4个级别 读未提交：read uncommitted(最低隔离级别) 事物A可以读取到事物B未提交的数据.(脏读现象) 开启两个命令行窗口，开启事务B当插入数据未提交时，在事物A中即可看到新插入的数据 读已提交：read committed 事物A只能读到事物B提交后的数据，不可重复读取数据 开启两个命令行窗口，开启事务B当插入数据提交后，在事物A中才可看到新插入的数据 可重复读：repeatable read(MySQL默认隔离级别) 事物A开启后，在事物A中读取数据一致(不管事物B是否修改或提交) 开启两个命令行窗口，开启事务B无论数据是否提交，在事物A中只可看到原来的数据 序列化读/串行化：serializable 线程同步(事物同步)读取数据最真实,效率最低 开启两个命令行窗口，开启事务B只有当事物B提交后，事物A才可进行操作(为事物B操作后的结果) 持久性 事物最终结束的一个保障。事物提交就相当于把没有保存在硬盘上的数据保存到硬盘上 索引","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"http://minqo.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Mysql","slug":"Mysql","permalink":"http://minqo.github.io/tags/Mysql/"}]},{"title":"JavaLearnNote","slug":"JavaLearnNote","date":"2022-05-19T01:01:14.000Z","updated":"2022-06-27T02:52:56.567Z","comments":true,"path":"2022/05/19/JavaLearnNote/","link":"","permalink":"http://minqo.github.io/2022/05/19/JavaLearnNote/","excerpt":"","text":"序之前一直在看黑马程序员的Java教程，平时记录也就是把视频中的ppt截图存放。但是时间久了发现之前很多内容都没有记牢，熟用。现在改用文字记录总结平时学习到的内容，同时学会熟练使用MarkDown写法。Java官方API文档。 JavaSe 零散点 Java文件的名称和Public修饰的类名相同，类中包含一个或多个方法，从main方法开始执行 final修饰的变量不可重新赋值改变，final声明的类为最终类，不能被继承 只有当被除数是负数时余数才是负数 强制类型转换–&gt;(类型)变量 sc.next()读取以空格为结束的字符串，sc.nextLine()读取以回车会结束的字符串 数值型字符串转换为整数–&gt;int 变量名 = Interger.parseInt(字符串) 数组间用=表示新数组指向原数组 重载方法-&gt;同名不同参 不可变集合List.of(“”,””)返回一个集合 finally之前的try中如果有return语句，会先执行finally语句再执行return语句 static{}可用于初始化，main方法之前执行 打印一个对象，会默认调用toString方法，如果没重写toString方法，就返回对象地址 接口中的方法默认由public abstract修饰，常量默认由public static final修饰 接口中被default修饰的方法可以直接补全方法的代码，接口被实现后可直接使用该方法 字符串 toCharArray()-&gt;将字符串拆分返回一个字符数组 substring(start,end)-&gt;从start开始到end截取字符串返回一个新字符串 replace(“a”,”b”)-&gt;将字符串中的a全部替换成b split(“,”)-&gt;将字符串以”,”分隔，返回一个字符串数组 多态格式: 父类 实例对象名称 = new 子类构造器 父类转子类(instanceof判断) -&gt; 子类 名称 = (子类)实例对象名称 方法调用: 编译看左边，运行看右边 变量调用: 编译，运行都看左边 时间类+格式化时间Date类Date类位于util包内，用于操作时间。格式: Date nowTime = new Date(ms);当ms存在时，将该毫秒值转换为日期对象 方法: getTime()获取毫秒值(距1970年01月01日 00时00分00秒)、System类中的currentTimeMillis()也可以获取毫秒值 SimpleDateFormat类格式: SimpleDateFormat 对象名称 = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss EEE a”); 调用对象的format(Date类)方法返回一个格式化后的字符串 调用对象的parse(格式化字符串)返回一个的Date类 实例: 123456789101112// 格式化时间SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss Ea&quot;);//获取当前时间String nowTime = &quot;2022年05月19日 21:10:53 星期六 上午&quot;;//将格式化后的时间转换为日期对象Date d = sdf.parse(nowTime);//获得日期对象的毫秒数Long time = d.getTime();//经过1天2小时2分钟2秒Long time2 = time + (24*3600+2*3600+2*60+2)*1000;//将时间格式化System.out.println(sdf.format(time2)); Calendar类Calendar是一个抽象类，不能直接创建对象。 方法: get(int field)返回日期某个字段信息(Year、Month、Day) set(int field,int value)修改日历的某个字段信息 add(int field,int amount)为某个字段增/减指定的值 getTime()拿到此刻日期对象，返回一个Date对象 getTimeInMillis()拿到此刻时间毫秒值 正则表达式方法: matches(),判断是否匹配正则表达式，返回Boolean类型 字符类 [abc]指定字符 [^abc]除了指定字符外的字符 [a-zA-Z]从a(A)到z(Z)包括 [a-d[m-p]]从a到d或从m到p [a-z&amp;&amp;[^def]]从a到z除去指定字符 [a-z&amp;&amp;[^m-p]]从a到z除去指定范围字符 预定义字符 .任何字符 \\d一个数字[0-9] \\D非数字[^0-9] \\s一个空白字符[\\t\\n\\x0B\\f\\r] \\S非空白字符[^\\s] \\w英文、数字、下划线[a-zA-Z_0-9] \\W一个非单词字符[^\\w] 贪婪量词 X? x,一次或无 x* x,0次或多次 x+ x,一次或多次 x[n] x,n次 x[n,] x,至少n次 x[n,m] x,至少n不超过m Lambda表达式简化函数式接口(接口中有且仅有一个抽象方法,通常加@FunctionalInterface注解)匿名内部类的代码写法 格式: (匿名内部类被重写方法的形参列表)-&gt;{被重写方法的代码} 实例: 12345678910111213141516public class LambdaDemo1 &#123; public static void main(String[] args) &#123; run( () -&gt;&#123; System.out.println(&quot;放飞&quot;); &#125;); &#125; public static void run(Play p)&#123; p.fly(); &#125;&#125;@FunctionalInterfaceinterface Play&#123; void fly();&#125; 泛型格式: 修饰符 class 类名&lt;泛型变量&gt;{} 泛型方法 修饰符 &lt;泛型变量&gt; 返回类型 名称(){} 泛型类 修饰符 interface 接口名称&lt;泛型变量&gt;{} 泛型接口 作用: 编译阶段指定数据类型 泛型接口可以让实现类选择当前功能需要操作的数据类型 拓展: 其中?作为通配符, 表示?必须是car或其子类(或其父类) 泛型和集合都只支持引用数据类型，不支持基本数据类型，集合中存储的元素认为是对象 迭代器格式:Iterator iterator()返回迭代器对象 方法: hasNext()询问当前位置是否有元素返回Boolean For循环增强格式:for(元素数据类型 变量名：可迭代对象){ 该变量就是元素} 可变参数格式:数据类型…参数名称(本质是一个数组) Collection集合方法: add(E e)将对象e添加到指定集合 clear()清除所有元素 remove(E e)将对象e移除当前集合 contains(Object obj)判断当前集合是否含指定对象 isEmpty()判断当前集合是否为空 size()返回集合中元素个数 toArray()集合中的元素存储到数组 List系列集合元素有序、可重复、有索引 ArrayList有序、可重复、有索引 LinkedList有序、可重复、有索引特有功能: addFirst(E e)从列表开头插入元素 addLast(E e)添加到末尾 getFirst()得到列表第一个元素 removeFirst()删除第一个 Set系列集合哈希值:JDK根据对象的地址，按照规则算出来的int类型的数值。hashCode()方法返回对象哈希值 元素无序、不重复、无索引 HashSet无序、不重复、无索引 LinkedHashSet有序、不重复、无索引 TreeSet按大小默认升序、不重复、无索引。 存储元素为对象时，实现Comparable接口重写compareTo方法自定义比较规则。 TreeSet集合有参构造器可以设置Comparator接口对应比较器对象，定制规则 Collections作用:Collections不属于集合，使用来操作集合的工具类 方法: addAll(Collection &lt;? super T&gt;)给集合批量添加元素 shuffle(List&lt;?&gt; list)打乱list集合元素顺序 sort(List list, Comparator&lt;? super T&gt; c)指定规则排序 Map集合格式: Map&lt;数据类型，数据类型&gt; maps = new Map&lt;&gt;()键值对应key=value,无序不重复，无索引 方法： put(K key,V value)添加元素 remove(Object key)根据键删除键值对元素 clear()移除所有键值对元素 containKey(Object key)判断集合是否包含指定的键 isEmpty()判断集合是否为空 size()集合长度，即键值对个数 HashMap无序、不重复、无索引 LinkedHashMap——有序、不重复、无索引 HashTable TreeMap排序、不重复、无索引 Stream流Stream操作集合或数组首先要得到stream流，再使用流的功能通过Collection接口中stream方法实现 方法： filter(Predicate &lt;? super T&gt; predicate)对流中数据进行过滤 limit(long maxSize)获取前几个元素 skip(long n)跳过前几个元素 distinct()去除流中重复元素 collect(Collector collector)开始收集stream流，指定收集器 toList()/toSet()/toMap(Function key,Function value)把元素收集到List/Set/Map集合中 实例1： 12345##去除最高工资和最低，计算平均list1.stream().sorted((e1,e2) -&gt; Ddouble.compare(e1.getSalary(),e2.getSalary)).skip(1).limit(list1.size()-1).forEach(e -&gt;&#123; allMoney += (e.getSalary());&#125;);averageMoney /= allMoney(list1.size()-2); 实例2： 12Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(&quot;王&quot;));List&lt;String&gt; wangList = s1.collect(Collectors.toList()); 异常 Error：系统级别问题，JVM退出 Exception：java.lang包下，异常类，可处理问题(包括运行时异常(RuntimeEXCEPTION)和编译时异常) 运行时异常 ArrayIndexOutOfBoundsException数组索引越界异常 NullPointerException空指针异常 ArithmeticException数字操作异常 ClassCastException类型转换异常 NumberFormatException数字转换异常 异常处理格式:try{ //监视可能出现异常的代码}catch(异常类型 变量){ //异常处理}Finally{ }或者方法直接将异常通过throws抛出给调用者 日志规范接口:Commons Logging(JCL)实现框架:Log4j、JUL(java.util.loggiing)、Logback Logback基于slf4j的日志规范实现的框架 技术模块： logback-core：为其他两个模块奠定基础 logback-classic：log4j的改良版本 logback-access：模块与Tomcat和Jetty等Servlet容器集成，提供HTTP访问功能 实现 在项目新建文件夹lib，导入Logback相关jar包(logback-classic、logback-core、slf4j-api)，并添加到项目依赖库 在Logback核心配置文件logback.xml拷贝到src目录下 在代码中获取日志对象(public static final Logger LOGGER=loggerFactory.getLogger()) 日志级别TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR(默认基本为debug) File类位于java.io.File下用于文件操作 方法: isDirectory()是否为文件夹 isFile()是否为文件 exists()是否存在该文件 getAbsolutePath()返回绝对路径字符串 getPath()路径转为字符串 getName()获取文件(夹)名称 lastModified()获取最后修改的时间毫秒值 创建File对象public File(String pathname)方法File f1 = new File(“D:/blog/myblog/data.txt”)方法: createNewFile()创建一个新的空文件夹(实例化对象时可直接创建) mkdir()只能创建一级文件夹 mkdirs()可创建多级文件夹 删除文件 delete()不走回收站且默认只能删除空文件夹 遍历 list()获取目录下所有一级文件名到一个字符串数组中返回 listFiles()获取目录下所有一级文件对象到一个文件对象数组中返回 实例： 12345678910111213141516171819//递归找文件public static void searchFile(File dir,String fileName)&#123; if(dir != null &amp;&amp; dir.isDirectorry())&#123; File[] files = dir.listFiles() if(files != null &amp;&amp; files.length&gt;0)&#123; for(File file : files)&#123; if(file.isFile())&#123; if(file.getNmae().contains(fileName))&#123; System.out.println(&quot;找到了&quot;+file.getAbsolutePath()); &#125; &#125;else&#123; searchFile(file,fileName); &#125; &#125; &#125; &#125;else&#123; System.out.println(&quot;当前搜索的位置不是文件夹&quot;); &#125;&#125; 编解码IDE默认字符集进行编码(UTF-8方式)byte[] bytes = name.getBytes(“GBK”);//指定GBK编码方式 IO流 flush()刷新流，还可继续写数据 close()关闭流，释放资源 字节流字节输入作用:以内存为基准，把磁盘文件中的数据以字节形式读取到内存中方法: FileInputStream(File file)创建字节输入流管道与源文件对象接通 FileInputStream(String pathname)创建字节输入流管道与源文件路径接通 read()每次读取一个字节返回，没有字节可读返回-1 read(byte[] buffer)每次读取一个字节数组返回，没有字节可读返回-1实例：1234File f = new File(&quot;Delete/src/data.txt&quot;);InputStream is = new FileInputStream(f);//或者直接将f换成路径byte[] buffer = new byte[(int)f.length()];System.out.println(new String(buffer)); 字节输出作用:以内存为基准，把内存中的数据以字节形式写出到磁盘文件中去的流方法: FileOutputStream(File file，Boolean append)创建字节输出流管道与源文件对象接通,可追加s数据 FileOutputStream(String filepath)创建字节输出流管道与源文件路径接通 write()写一个字节出去 write(byte[] buffer，int pos，int len)写一个字节数组的一部分出去 字符流字符流输入作用:以内存为基准，把磁盘文件中的数据以字符形式读取到内存中方法: FileReader(File file)创建字符输入流管道与源文件对象接通 FileReader(String pathname)创建字符输入流通道与源文件路径接通 read()每次读取一个字符返回，没有字符可读返回-1‘ read(char[] buffer)每次读取一个字符数组，返回读取字符个数，无字符可读返回-1实例:1234567Reader fr = FileReader(&quot;Delete/src/data.txt&quot;);char[] buffer = new char[1024];int len;while((len = fr.read(buffer)) != -1)&#123; String rs = new String(buffer, 0 ,len); System.out.print(rs);&#125; 字符流输出作用:以内存为基准，把内存中的数据以字符形式写到磁盘文件中的流方法: FileWriter(File file,boolean append)创建字符输出流管道与源文件对象接通,可追加数据 FileWriter(String filepath)创建字符输出流管道与源文件路径接通 缓冲流作用:缓冲流自带缓冲区、可以提高原始字节流、字符流读写的性能数据源-&gt;字节流-&gt;缓冲流-&gt;内存-&gt;缓冲流-&gt;字节流-&gt;目的地 字节缓冲流字节缓冲输入流作用:提高字节输入流读取数据的性能，构造器:public BufferedInputStream(inputStream is)可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能 字符缓冲输入流作用:提高字符输入流读取数据的性能，按行读取数据构造器:public BufferedReader(Reader r)把低级的字符输入流包装成一个高级的字符输入流通道方法: readLine()读取一行数据返回，无行可读返回null实例:123456Reader fr = new FileReader(&quot;Delete/src/data.txt&quot;);BufferedReader br = new BufferedReader(fr);String line;while((line = br.readLine()) != null)&#123; System.out.println(line);&#125; 字符缓冲输出流作用:提高字符输出流读取数据的性能，有换行功能构造器:public BufferedWriter(Writer w)把低级的字符输出流包装成一个高级的字符输出流通道方法: newLine()换行操作 字符转换流字符输入转换流构造器：public InputStreamReader(InputStream is,String charset)把原始字节输入流按代码指定编码转换成字符输入流 字符输出转换流构造器public OutputStreamWriter(OutputStream os,String charset)把原始字节输出流按代码指定编码转换成字符输出流 打印流作用：实现方便、高效的打印数据到文件中去构造器：public PrintStream(OutputStream os/File f/String filepath)方法；public void print(Xxx xx)打印任意类型数据出来实例： 12345System.out.println(&quot;a&quot;);OutputStream os = new FileOutputStream(&quot;Delete/src/data1.txt&quot;,true);PrintStream ps = new PrintStream(os);System.setOut(ps);//改变打印流位置(重定向)System.out.print(&quot;asdasz&quot;); 多线程线程：一个程序内部的一条执行路径","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"http://minqo.github.io/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://minqo.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"如何用py做一个exe应用程序","slug":"如何做一个exe应用程序","date":"2022-02-05T11:51:54.000Z","updated":"2022-04-28T00:56:45.688Z","comments":true,"path":"2022/02/05/如何做一个exe应用程序/","link":"","permalink":"http://minqo.github.io/2022/02/05/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AAexe%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","excerpt":"工具 pycharm pip(Python包管理工具) pyinstaller库 操作安装pip先在pip官网下载pip压缩包并压缩,然后在命令行进入到压缩完后的文件夹目录并输入python setup.py install,安装完成后输入cd..(退出文件夹),输入命令pip –version可以看到版本则安装成功。最后将python目录中的script填入环境变量 安装pyinstaller库在命令行输入pip install pyinstall -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com 这里将pip源换成清华源、阿里源等都适用。","text":"工具 pycharm pip(Python包管理工具) pyinstaller库 操作安装pip先在pip官网下载pip压缩包并压缩,然后在命令行进入到压缩完后的文件夹目录并输入python setup.py install,安装完成后输入cd..(退出文件夹),输入命令pip –version可以看到版本则安装成功。最后将python目录中的script填入环境变量 安装pyinstaller库在命令行输入pip install pyinstall -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com 这里将pip源换成清华源、阿里源等都适用。 代码这里写的是一个查询文件夹内代码行数的程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import easygui as gimport osdef show(start_dir): lines = 0 total = 0 text = &#x27;&#x27; for i in source_list: lines = source_list[i] total += lines text += (&#x27;【%s】文件共有%d个，代码量共%d行\\n&#x27; % (i,file_list[i],lines)) if total &lt; 10000: msg = &#x27;您目前共累积编写了%d行代码，完成进度:%.2f %% \\n离10万行代码还差%d行，请继续努力！&#x27; % (total,total/1000,100000-total) title = &#x27;结果&#x27; g.textbox(msg,title,text) elif total &gt; 10000: msg = &#x27;您目前共累积编写了%d行代码，完成进度:%.2f %% \\n超过10万行代码%d行，请继续努力！&#x27; % (total, total / 1000, total - 100000) title = &#x27;结果&#x27; g.textbox(msg, title, text) else : msg =&#x27;完成进度:%.2f %% \\n刚好写了10万行代码，请继续努力！&#x27; % (total / 1000) title = &#x27;结果&#x27; g.textbox(msg,title,text)def num_file(file_name): lines = 0 with open(file_name) as f: print(&#x27;正在分析【%s】文件&#x27; % file_name) try: for each_line in f: lines += 1 except UnicodeDecodeError : pass #不计因编码产生的差错 return linesdef search_file(start_dir): os.chdir(start_dir) for each_file in os.listdir(os.curdir) : ext = os.path.splitext(each_file)[1] if ext in target: # 查询代码量 num = num_file(each_file) try : file_list[ext] += 1 except KeyError: file_list[ext] = 1 try : source_list[ext] += num except KeyError: source_list[ext] = num if os.path.isdir(each_file): search_file(each_file) os.chdir(os.pardir)target = [&#x27;.c&#x27;,&#x27;.css&#x27;,&#x27;.py&#x27;,&#x27;.java&#x27;,&#x27;.cpp&#x27;,&#x27;.html&#x27;,&#x27;.js&#x27;]file_list = &#123;&#125;source_list = &#123;&#125;g.msgbox(&#x27;请打开你需要查询代码量的文件夹&#x27;,&#x27;代码量查询&#x27;)path = g.diropenbox(&#x27;请选择代码库&#x27;)search_file(path)show(path) exe文件打包将写完的.py文件放在文件夹中,在命令行cd进入py文件所在目录，输入pyinstaller -F -w 名.py(-w是消除exe文件控制框)等待完成后就会生成exe程序文件 快捷式在桌面新建快捷式，选择到所完成的exe文件，之后就可以更改名称及图标了","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"python","slug":"python","permalink":"http://minqo.github.io/tags/python/"}]},{"title":"如何用c语言做一个简易推箱子游戏","slug":"如何用c语言做一个简易推箱子游戏","date":"2021-11-24T12:23:07.000Z","updated":"2021-11-25T06:57:20.489Z","comments":true,"path":"2021/11/24/如何用c语言做一个简易推箱子游戏/","link":"","permalink":"http://minqo.github.io/2021/11/24/%E5%A6%82%E4%BD%95%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。","text":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。 二.角色的移动在打印地图中，我们确定了角色的位置。所以要想让角色移动，得要让角色的坐标随输入的移动位置而相应的改变，然后再重新打印地图。(细节:定义新行、列的指针指向初始位置的地址，移动后新坐标的值改变–将初始坐标保存) 三.移动过程中的各种情况1.移动方向为墙或者目标点输出禁止前行/坐标不改变2.移动的目标点是空白角色对应的值赋值给新坐标，空白的值赋给人的原坐标，再把新坐标赋值给原坐标(新一轮的坐标替换)3.移动的目标点是箱子将新坐标的值赋值给下一个坐标，移动角色，下一个坐标(箱子的坐标)对应改变①.改变的位置是墙或箱子输出移动不了②.改变的位置是空白箱子的值赋给改变后的坐标，角色的值赋给箱子的坐标，空白的值赋给原坐标的指针，再原坐标指针指向角色的位置坐标(保证指针一直指向角色位置的坐标)③.改变的位置是目标点在②中，目标点坐标对应的值将被箱子的值覆盖，不需设置额外变量计算目标点个数(在重新打印地图中计算目标点的值的个数) 四.判断先对地图做一次循环，确定目标点的个数，并赋值给一个变量，当这个这个变量为0时，游戏胜利。(在移动中可设置一个输入值为认输) 五.优化1.设置一个菜单，让玩家进行选择 2.设置多关卡 3.利用函数，结构清晰 六.问题1.地图需要自己排版2.关卡需要自己设计，每次加一个关卡都要重写一个函数3.游戏单调，无音效，图片特效。七.所学1.学习了大程序的函数结构布局，让代码清晰2.学习了_getch()、exit(0)、system(“cls”)、等新知识3.c语言代码的新用法八.游戏实况","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"游戏","slug":"游戏","permalink":"http://minqo.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"第一篇的感悟","slug":"第一篇的感悟","date":"2021-11-24T10:58:53.000Z","updated":"2021-11-25T06:57:17.302Z","comments":true,"path":"2021/11/24/第一篇的感悟/","link":"","permalink":"http://minqo.github.io/2021/11/24/%E7%AC%AC%E4%B8%80%E7%AF%87%E7%9A%84%E6%84%9F%E6%82%9F/","excerpt":"","text":"待会再感悟","categories":[],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://minqo.github.io/tags/%E6%84%9F%E6%82%9F/"}]}],"categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"http://minqo.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Mysql","slug":"Mysql","permalink":"http://minqo.github.io/tags/Mysql/"},{"name":"Java","slug":"Java","permalink":"http://minqo.github.io/tags/Java/"},{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"python","slug":"python","permalink":"http://minqo.github.io/tags/python/"},{"name":"游戏","slug":"游戏","permalink":"http://minqo.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"感悟","slug":"感悟","permalink":"http://minqo.github.io/tags/%E6%84%9F%E6%82%9F/"}]}