{"meta":{"title":"MinQo的blog","subtitle":"","description":"","author":"MinQo","url":"http://MinQo.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-01-21T07:41:54.000Z","updated":"2022-01-21T07:44:29.871Z","comments":true,"path":"tags/index.html","permalink":"http://minqo.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-21T07:43:33.000Z","updated":"2022-01-21T07:44:13.802Z","comments":true,"path":"categories/index.html","permalink":"http://minqo.github.io/categories/index.html","excerpt":"","text":""},{"title":"四大皆空","date":"2022-01-21T07:47:16.467Z","updated":"2022-01-21T07:47:16.455Z","comments":true,"path":"/404.html","permalink":"http://minqo.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2022-01-21T07:45:21.000Z","updated":"2022-04-28T00:54:00.805Z","comments":true,"path":"about/index.html","permalink":"http://minqo.github.io/about/index.html","excerpt":"","text":"北京信息科技大学:MinQo联系方式：qq:2537876428wechat:iMinQo"},{"title":"links","date":"2022-01-21T07:47:38.000Z","updated":"2022-01-21T07:47:38.819Z","comments":true,"path":"links/index.html","permalink":"http://minqo.github.io/links/index.html","excerpt":"","text":""},{"title":"如何用c语言做一个简易推箱子游戏","date":"2021-11-24T12:23:07.000Z","updated":"2021-11-25T06:57:20.489Z","comments":true,"path":"categories/游戏/如何用c语言做一个简易推箱子游戏.html","permalink":"http://minqo.github.io/categories/%E6%B8%B8%E6%88%8F/%E5%A6%82%E4%BD%95%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F.html","excerpt":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。","text":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。 二.角色的移动在打印地图中，我们确定了角色的位置。所以要想让角色移动，得要让角色的坐标随输入的移动位置而相应的改变，然后再重新打印地图。(细节:定义新行、列的指针指向初始位置的地址，移动后新坐标的值改变–将初始坐标保存) 三.移动过程中的各种情况1.移动方向为墙或者目标点输出禁止前行/坐标不改变2.移动的目标点是空白角色对应的值赋值给新坐标，空白的值赋给人的原坐标，再把新坐标赋值给原坐标(新一轮的坐标替换)3.移动的目标点是箱子将新坐标的值赋值给下一个坐标，移动角色，下一个坐标(箱子的坐标)对应改变①.改变的位置是墙或箱子输出移动不了②.改变的位置是空白箱子的值赋给改变后的坐标，角色的值赋给箱子的坐标，空白的值赋给原坐标的指针，再原坐标指针指向角色的位置坐标(保证指针一直指向角色位置的坐标)③.改变的位置是目标点在②中，目标点坐标对应的值将被箱子的值覆盖，不需设置额外变量计算目标点个数(在重新打印地图中计算目标点的值的个数) 四.判断先对地图做一次循环，确定目标点的个数，并赋值给一个变量，当这个这个变量为0时，游戏胜利。(在移动中可设置一个输入值为认输) 五.优化1.设置一个菜单，让玩家进行选择 2.设置多关卡 3.利用函数，结构清晰 六.问题1.地图需要自己排版2.关卡需要自己设计，每次加一个关卡都要重写一个函数3.游戏单调，无音效，图片特效。七.所学1.学习了大程序的函数结构布局，让代码清晰2.学习了_getch()、exit(0)、system(“cls”)、等新知识3.c语言代码的新用法八.游戏实况"}],"posts":[{"title":"MysqlLearnNote","slug":"MysqlLearnNote","date":"2022-06-19T01:01:01.000Z","updated":"2022-06-19T01:01:01.167Z","comments":true,"path":"2022/06/19/MysqlLearnNote/","link":"","permalink":"http://minqo.github.io/2022/06/19/MysqlLearnNote/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaLearnNote","slug":"JavaLearnNote","date":"2022-05-19T01:01:14.000Z","updated":"2022-06-20T00:21:07.004Z","comments":true,"path":"2022/05/19/JavaLearnNote/","link":"","permalink":"http://minqo.github.io/2022/05/19/JavaLearnNote/","excerpt":"","text":"序之前一直在看黑马程序员的Java教程，平时记录也就是把视频中的ppt截图存放。但是时间久了发现之前很多内容都没有记牢，熟用。现在改用文字记录总结平时学习到的内容，同时学会熟练使用MarkDown写法。Java官方API文档。 JavaSe 零散点 Java文件的名称和Public修饰的类名相同，类中包含一个或多个方法，从main方法开始执行 final修饰的变量不可重新赋值改变，final声明的类为最终类，不能被继承 只有当被除数是负数时余数才是负数 强制类型转换–&gt;(类型)变量 sc.next()读取以空格为结束的字符串，sc.nextLine()读取以回车会结束的字符串 数值型字符串转换为整数–&gt;int 变量名 = Interger.parseInt(字符串) 数组间用=表示新数组指向原数组 重载方法-&gt;同名不同参 不可变集合List.of(“”,””)返回一个集合 finally之前的try中如果有return语句，会先执行finally语句再执行return语句 static{}可用于初始化，main方法之前执行 打印一个对象，会默认调用toString方法，如果没重写toString方法，就返回对象地址 接口中的方法默认由public abstract修饰，常量默认由public static final修饰 接口中被default修饰的方法可以直接补全方法的代码，接口被实现后可直接使用该方法 字符串 toCharArray()-&gt;将字符串拆分返回一个字符数组 substring(start,end)-&gt;从start开始到end截取字符串返回一个新字符串 replace(“a”,”b”)-&gt;将字符串中的a全部替换成b split(“,”)-&gt;将字符串以”,”分隔，返回一个字符串数组 多态格式: 父类 实例对象名称 = new 子类构造器 父类转子类(instanceof判断) -&gt; 子类 名称 = (子类)实例对象名称 方法调用: 编译看左边，运行看右边 变量调用: 编译，运行都看左边 时间类+格式化时间Date类Date类位于util包内，用于操作时间。格式: Date nowTime = new Date(ms);当ms存在时，将该毫秒值转换为日期对象 方法: getTime()获取毫秒值(距1970年01月01日 00时00分00秒)、System类中的currentTimeMillis()也可以获取毫秒值 SimpleDateFormat类格式: SimpleDateFormat 对象名称 = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss EEE a”); 调用对象的format(Date类)方法返回一个格式化后的字符串 调用对象的parse(格式化字符串)返回一个的Date类 实例: 123456789101112// 格式化时间SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss Ea&quot;);//获取当前时间String nowTime = &quot;2022年05月19日 21:10:53 星期六 上午&quot;;//将格式化后的时间转换为日期对象Date d = sdf.parse(nowTime);//获得日期对象的毫秒数Long time = d.getTime();//经过1天2小时2分钟2秒Long time2 = time + (24*3600+2*3600+2*60+2)*1000;//将时间格式化System.out.println(sdf.format(time2)); Calendar类Calendar是一个抽象类，不能直接创建对象。 方法: get(int field)返回日期某个字段信息(Year、Month、Day) set(int field,int value)修改日历的某个字段信息 add(int field,int amount)为某个字段增/减指定的值 getTime()拿到此刻日期对象，返回一个Date对象 getTimeInMillis()拿到此刻时间毫秒值 正则表达式方法: matches(),判断是否匹配正则表达式，返回Boolean类型 字符类 [abc]指定字符 [^abc]除了指定字符外的字符 [a-zA-Z]从a(A)到z(Z)包括 [a-d[m-p]]从a到d或从m到p [a-z&amp;&amp;[^def]]从a到z除去指定字符 [a-z&amp;&amp;[^m-p]]从a到z除去指定范围字符 预定义字符 .任何字符 \\d一个数字[0-9] \\D非数字[^0-9] \\s一个空白字符[\\t\\n\\x0B\\f\\r] \\S非空白字符[^\\s] \\w英文、数字、下划线[a-zA-Z_0-9] \\W一个非单词字符[^\\w] 贪婪量词 X? x,一次或无 x* x,0次或多次 x+ x,一次或多次 x[n] x,n次 x[n,] x,至少n次 x[n,m] x,至少n不超过m Lambda表达式简化函数式接口(接口中有且仅有一个抽象方法,通常加@FunctionalInterface注解)匿名内部类的代码写法 格式: (匿名内部类被重写方法的形参列表)-&gt;{被重写方法的代码} 实例: 12345678910111213141516public class LambdaDemo1 &#123; public static void main(String[] args) &#123; run( () -&gt;&#123; System.out.println(&quot;放飞&quot;); &#125;); &#125; public static void run(Play p)&#123; p.fly(); &#125;&#125;@FunctionalInterfaceinterface Play&#123; void fly();&#125; 泛型格式: 修饰符 class 类名&lt;泛型变量&gt;{} 泛型方法 修饰符 &lt;泛型变量&gt; 返回类型 名称(){} 泛型类 修饰符 interface 接口名称&lt;泛型变量&gt;{} 泛型接口 作用: 编译阶段指定数据类型 泛型接口可以让实现类选择当前功能需要操作的数据类型 拓展: 其中?作为通配符, 表示?必须是car或其子类(或其父类) 泛型和集合都只支持引用数据类型，不支持基本数据类型，集合中存储的元素认为是对象 迭代器格式:Iterator iterator()返回迭代器对象 方法: hasNext()询问当前位置是否有元素返回Boolean For循环增强格式:for(元素数据类型 变量名：可迭代对象){ 该变量就是元素} 可变参数格式:数据类型…参数名称(本质是一个数组) Collection集合方法: add(E e)将对象e添加到指定集合 clear()清除所有元素 remove(E e)将对象e移除当前集合 contains(Object obj)判断当前集合是否含指定对象 isEmpty()判断当前集合是否为空 size()返回集合中元素个数 toArray()集合中的元素存储到数组 List系列集合元素有序、可重复、有索引 ArrayList有序、可重复、有索引 LinkedList有序、可重复、有索引特有功能: addFirst(E e)从列表开头插入元素 addLast(E e)添加到末尾 getFirst()得到列表第一个元素 removeFirst()删除第一个 Set系列集合哈希值:JDK根据对象的地址，按照规则算出来的int类型的数值。hashCode()方法返回对象哈希值 元素无序、不重复、无索引 HashSet无序、不重复、无索引 LinkedHashSet有序、不重复、无索引 TreeSet按大小默认升序、不重复、无索引。 存储元素为对象时，实现Comparable接口重写compareTo方法自定义比较规则。 TreeSet集合有参构造器可以设置Comparator接口对应比较器对象，定制规则 Collections作用:Collections不属于集合，使用来操作集合的工具类 方法: addAll(Collection &lt;? super T&gt;)给集合批量添加元素 shuffle(List&lt;?&gt; list)打乱list集合元素顺序 sort(List list, Comparator&lt;? super T&gt; c)指定规则排序 Map集合格式: Map&lt;数据类型，数据类型&gt; maps = new Map&lt;&gt;()键值对应key=value,无序不重复，无索引 方法： put(K key,V value)添加元素 remove(Object key)根据键删除键值对元素 clear()移除所有键值对元素 containKey(Object key)判断集合是否包含指定的键 isEmpty()判断集合是否为空 size()集合长度，即键值对个数 HashMap无序、不重复、无索引 LinkedHashMap——有序、不重复、无索引 HashTable TreeMap排序、不重复、无索引 Stream流Stream操作集合或数组首先要得到stream流，再使用流的功能通过Collection接口中stream方法实现 方法： filter(Predicate &lt;? super T&gt; predicate)对流中数据进行过滤 limit(long maxSize)获取前几个元素 skip(long n)跳过前几个元素 distinct()去除流中重复元素 collect(Collector collector)开始收集stream流，指定收集器 toList()/toSet()/toMap(Function key,Function value)把元素收集到List/Set/Map集合中 实例1： 12345##去除最高工资和最低，计算平均list1.stream().sorted((e1,e2) -&gt; Ddouble.compare(e1.getSalary(),e2.getSalary)).skip(1).limit(list1.size()-1).forEach(e -&gt;&#123; allMoney += (e.getSalary());&#125;);averageMoney /= allMoney(list1.size()-2); 实例2： 12Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(&quot;王&quot;));List&lt;String&gt; wangList = s1.collect(Collectors.toList()); 异常 Error：系统级别问题，JVM退出 Exception：java.lang包下，异常类，可处理问题(包括运行时异常(RuntimeEXCEPTION)和编译时异常) 运行时异常 ArrayIndexOutOfBoundsException数组索引越界异常 NullPointerException空指针异常 ArithmeticException数字操作异常 ClassCastException类型转换异常 NumberFormatException数字转换异常 异常处理格式:try{ //监视可能出现异常的代码}catch(异常类型 变量){ //异常处理}Finally{ }或者方法直接将异常通过throws抛出给调用者 日志规范接口:Commons Logging(JCL)实现框架:Log4j、JUL(java.util.loggiing)、Logback Logback基于slf4j的日志规范实现的框架 技术模块： logback-core：为其他两个模块奠定基础 logback-classic：log4j的改良版本 logback-access：模块与Tomcat和Jetty等Servlet容器集成，提供HTTP访问功能 实现 在项目新建文件夹lib，导入Logback相关jar包(logback-classic、logback-core、slf4j-api)，并添加到项目依赖库 在Logback核心配置文件logback.xml拷贝到src目录下 在代码中获取日志对象(public static final Logger LOGGER=loggerFactory.getLogger()) 日志级别TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR(默认基本为debug) File类位于java.io.File下用于文件操作 方法: isDirectory()是否为文件夹 isFile()是否为文件 exists()是否存在该文件 getAbsolutePath()返回绝对路径字符串 getPath()路径转为字符串 getName()获取文件(夹)名称 lastModified()获取最后修改的时间毫秒值 创建File对象public File(String pathname)方法File f1 = new File(“D:/blog/myblog/data.txt”)方法: createNewFile()创建一个新的空文件夹(实例化对象时可直接创建) mkdir()只能创建一级文件夹 mkdirs()可创建多级文件夹 删除文件 delete()不走回收站且默认只能删除空文件夹 遍历 list()获取目录下所有一级文件名到一个字符串数组中返回 listFiles()获取目录下所有一级文件对象到一个文件对象数组中返回 实例：···java//递归找文件public static void searchFile(File dir,String fileName){ if(dir != null &amp;&amp; dir.isDirectorry()){ File[] files = dir.listFiles() if(files != null &amp;&amp; files.length&gt;0){ for(File file : files){ if(file.isFile()){ if(file.getNmae().contains(fileName)){ System.out.println(“找到了”+file.getAbsolutePath()); } }else{ searchFile(file,fileName); } } } }else{ System.out.println(“当前搜索的位置不是文件夹”); }} #### 编解码 IDE默认字符集进行编码(UTF-8方式) byte[] bytes = name.getBytes(&quot;GBK&quot;);//指定GBK编码方式 &lt;!-- IO流 --&gt; ### IO流","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"http://minqo.github.io/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://minqo.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"如何用py做一个exe应用程序","slug":"如何做一个exe应用程序","date":"2022-02-05T11:51:54.000Z","updated":"2022-04-28T00:56:45.688Z","comments":true,"path":"2022/02/05/如何做一个exe应用程序/","link":"","permalink":"http://minqo.github.io/2022/02/05/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AAexe%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","excerpt":"工具 pycharm pip(Python包管理工具) pyinstaller库 操作安装pip先在pip官网下载pip压缩包并压缩,然后在命令行进入到压缩完后的文件夹目录并输入python setup.py install,安装完成后输入cd..(退出文件夹),输入命令pip –version可以看到版本则安装成功。最后将python目录中的script填入环境变量 安装pyinstaller库在命令行输入pip install pyinstall -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com 这里将pip源换成清华源、阿里源等都适用。","text":"工具 pycharm pip(Python包管理工具) pyinstaller库 操作安装pip先在pip官网下载pip压缩包并压缩,然后在命令行进入到压缩完后的文件夹目录并输入python setup.py install,安装完成后输入cd..(退出文件夹),输入命令pip –version可以看到版本则安装成功。最后将python目录中的script填入环境变量 安装pyinstaller库在命令行输入pip install pyinstall -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com 这里将pip源换成清华源、阿里源等都适用。 代码这里写的是一个查询文件夹内代码行数的程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import easygui as gimport osdef show(start_dir): lines = 0 total = 0 text = &#x27;&#x27; for i in source_list: lines = source_list[i] total += lines text += (&#x27;【%s】文件共有%d个，代码量共%d行\\n&#x27; % (i,file_list[i],lines)) if total &lt; 10000: msg = &#x27;您目前共累积编写了%d行代码，完成进度:%.2f %% \\n离10万行代码还差%d行，请继续努力！&#x27; % (total,total/1000,100000-total) title = &#x27;结果&#x27; g.textbox(msg,title,text) elif total &gt; 10000: msg = &#x27;您目前共累积编写了%d行代码，完成进度:%.2f %% \\n超过10万行代码%d行，请继续努力！&#x27; % (total, total / 1000, total - 100000) title = &#x27;结果&#x27; g.textbox(msg, title, text) else : msg =&#x27;完成进度:%.2f %% \\n刚好写了10万行代码，请继续努力！&#x27; % (total / 1000) title = &#x27;结果&#x27; g.textbox(msg,title,text)def num_file(file_name): lines = 0 with open(file_name) as f: print(&#x27;正在分析【%s】文件&#x27; % file_name) try: for each_line in f: lines += 1 except UnicodeDecodeError : pass #不计因编码产生的差错 return linesdef search_file(start_dir): os.chdir(start_dir) for each_file in os.listdir(os.curdir) : ext = os.path.splitext(each_file)[1] if ext in target: # 查询代码量 num = num_file(each_file) try : file_list[ext] += 1 except KeyError: file_list[ext] = 1 try : source_list[ext] += num except KeyError: source_list[ext] = num if os.path.isdir(each_file): search_file(each_file) os.chdir(os.pardir)target = [&#x27;.c&#x27;,&#x27;.css&#x27;,&#x27;.py&#x27;,&#x27;.java&#x27;,&#x27;.cpp&#x27;,&#x27;.html&#x27;,&#x27;.js&#x27;]file_list = &#123;&#125;source_list = &#123;&#125;g.msgbox(&#x27;请打开你需要查询代码量的文件夹&#x27;,&#x27;代码量查询&#x27;)path = g.diropenbox(&#x27;请选择代码库&#x27;)search_file(path)show(path) exe文件打包将写完的.py文件放在文件夹中,在命令行cd进入py文件所在目录，输入pyinstaller -F -w 名.py(-w是消除exe文件控制框)等待完成后就会生成exe程序文件 快捷式在桌面新建快捷式，选择到所完成的exe文件，之后就可以更改名称及图标了","categories":[],"tags":[{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"python","slug":"python","permalink":"http://minqo.github.io/tags/python/"}]},{"title":"如何用c语言做一个简易推箱子游戏","slug":"如何用c语言做一个简易推箱子游戏","date":"2021-11-24T12:23:07.000Z","updated":"2021-11-25T06:57:20.489Z","comments":true,"path":"2021/11/24/如何用c语言做一个简易推箱子游戏/","link":"","permalink":"http://minqo.github.io/2021/11/24/%E5%A6%82%E4%BD%95%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。","text":"零.设计思路打印地图，通过移动角色将箱子推到目标点，当图中箱子数为0时，游戏胜利。 一.打印地图将空白，墙，角色，目标点设置为不同值，填充在二维数组中，再通过循环，将地图打印。 二.角色的移动在打印地图中，我们确定了角色的位置。所以要想让角色移动，得要让角色的坐标随输入的移动位置而相应的改变，然后再重新打印地图。(细节:定义新行、列的指针指向初始位置的地址，移动后新坐标的值改变–将初始坐标保存) 三.移动过程中的各种情况1.移动方向为墙或者目标点输出禁止前行/坐标不改变2.移动的目标点是空白角色对应的值赋值给新坐标，空白的值赋给人的原坐标，再把新坐标赋值给原坐标(新一轮的坐标替换)3.移动的目标点是箱子将新坐标的值赋值给下一个坐标，移动角色，下一个坐标(箱子的坐标)对应改变①.改变的位置是墙或箱子输出移动不了②.改变的位置是空白箱子的值赋给改变后的坐标，角色的值赋给箱子的坐标，空白的值赋给原坐标的指针，再原坐标指针指向角色的位置坐标(保证指针一直指向角色位置的坐标)③.改变的位置是目标点在②中，目标点坐标对应的值将被箱子的值覆盖，不需设置额外变量计算目标点个数(在重新打印地图中计算目标点的值的个数) 四.判断先对地图做一次循环，确定目标点的个数，并赋值给一个变量，当这个这个变量为0时，游戏胜利。(在移动中可设置一个输入值为认输) 五.优化1.设置一个菜单，让玩家进行选择 2.设置多关卡 3.利用函数，结构清晰 六.问题1.地图需要自己排版2.关卡需要自己设计，每次加一个关卡都要重写一个函数3.游戏单调，无音效，图片特效。七.所学1.学习了大程序的函数结构布局，让代码清晰2.学习了_getch()、exit(0)、system(“cls”)、等新知识3.c语言代码的新用法八.游戏实况","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"游戏","slug":"游戏","permalink":"http://minqo.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"}]},{"title":"第一篇的感悟","slug":"第一篇的感悟","date":"2021-11-24T10:58:53.000Z","updated":"2021-11-25T06:57:17.302Z","comments":true,"path":"2021/11/24/第一篇的感悟/","link":"","permalink":"http://minqo.github.io/2021/11/24/%E7%AC%AC%E4%B8%80%E7%AF%87%E7%9A%84%E6%84%9F%E6%82%9F/","excerpt":"","text":"待会再感悟","categories":[],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://minqo.github.io/tags/%E6%84%9F%E6%82%9F/"}]}],"categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://minqo.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"http://minqo.github.io/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://minqo.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"实践","slug":"实践","permalink":"http://minqo.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"python","slug":"python","permalink":"http://minqo.github.io/tags/python/"},{"name":"游戏","slug":"游戏","permalink":"http://minqo.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"感悟","slug":"感悟","permalink":"http://minqo.github.io/tags/%E6%84%9F%E6%82%9F/"}]}